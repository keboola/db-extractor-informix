<?php

declare(strict_types=1);

namespace Keboola\DbExtractor\Metadata;

use Keboola\DbExtractor\TableResultFormat\Metadata\Builder\ColumnBuilder;
use Keboola\DbExtractor\TableResultFormat\Metadata\Builder\TableBuilder;
use Keboola\DbExtractorConfig\Configuration\ValueObject\DatabaseConfig;

/**
 * Parses results of queries generated by MetadataQueryFactory.
 * Code is database specific and cannot be universal for all ODBC drivers.
 */
class OdbcMetadataProcessor
{
    public const SCHEMA = 'default';

    protected DatabaseConfig $dbConfig;

    public function __construct(DatabaseConfig $dbConfig)
    {
        $this->dbConfig = $dbConfig;
    }

    public function processTableMetadata(TableBuilder $builder, array $tableResult): void
    {
        $builder
            ->setName($tableResult['tabname'])
            ->setType(strtoupper($tableResult['tabtype']) === 'V' ? 'view' : 'table');

        // In informix owner = schema
        $builder->setSchema($tableResult['owner']);
    }

    public function processColumnMetadata(ColumnBuilder $builder, array $columnResult): void
    {
        // https://www.ibm.com/support/knowledgecenter/en/SSGU8G_14.1.0/com.ibm.sqlr.doc/ids_sqr_025.htm
        // See link: coltype value is incremented by 256 if the column does not allow NULL values.
        $colTypeCode = ((int) $columnResult['coltype']) % 256;
        $isNullable = (int) $columnResult['coltype'] < 256;
        $colType = $this->mapColTypeCodeToName($colTypeCode);
        $builder
            ->setName($columnResult['colname'])
            ->setOrdinalPosition((int) $columnResult['colno'])
            ->setType($colType)
            ->setNullable($isNullable);

        // Parse column length
        // https://www.ibm.com/support/knowledgecenter/en/SSGU8G_14.1.0/com.ibm.sqlr.doc/ids_sqr_027.htm
        if (in_array($colType, ['MONEY', 'DECIMAL'], true)) {
            $scale = $columnResult['collength'] % 256;
            $precision = floor($columnResult['collength'] / 256);
            $builder->setLength("$precision,$scale");
        } elseif (preg_match('~CHAR~', $colType)) {
            $builder->setLength($columnResult['collength']);
        }
    }

    public function processColumnConstraintsMetadata(ColumnBuilder $builder, array $constraintResult): void
    {
        if (isset($constraintResult['constrname'])) {
            $builder->addConstraint($constraintResult['constrname']);
        }

        if ($constraintResult['constrtype'] === 'P') {
            $builder->setPrimaryKey(true);
        }

        if ($constraintResult['constrtype'] === 'R' && isset($constraintResult['refcolname'])) {
            $builder
                ->addForeignKey()
                ->setName($constraintResult['colname'])
                ->setRefColumn($constraintResult['refcolname'])
                ->setRefSchema($constraintResult['reftabowner'])
                ->setRefTable($constraintResult['reftab']);
        }
    }

    protected function mapColTypeCodeToName(int $code): string
    {
        // https://www.ibm.com/support/knowledgecenter/en/SSGU8G_14.1.0/com.ibm.sqlr.doc/ids_sqr_025.htm
        switch ($code) {
            case 0:
                return 'CHAR';
            case 1:
                return 'SMALLINT';
            case 2:
                return 'INTEGER';
            case 3:
                return 'FLOAT';
            case 4:
                return 'SMALLFLOAT';
            case 5:
                return 'DECIMAL';
            case 6:
                return 'SERIAL';
            case 7:
                return 'DATE';
            case 8:
                return 'MONEY';
            case 9:
                return 'NULL';
            case 10:
                return 'DATETIME';
            case 11:
                return 'BYTE';
            case 12:
                return 'TEXT';
            case 13:
                return 'VARCHAR';
            case 14:
                return 'INTERVAL';
            case 15:
                return 'NCHAR';
            case 16:
                return 'NVARCHAR';
            case 17:
                return 'INT8';
            case 18:
                return 'SERIAL8';
            case 19:
                return 'SET';
            case 20:
                return 'MULTISET';
            case 21:
                return 'LIST';
            case 22:
                return 'ROW';
            case 23:
                return 'COLLECTION';
            case 40:
            case 42:
                return 'LVARCHAR';
            case 41:
                return 'BLOB';
            case 45:
                return 'BOOLEAN';
            case 52:
                return 'BIGINT';
            case 53:
                return 'BIGSERIAL';
            case 2061:
                return 'IDSSECURITYLABEL';
            case 4118:
                return 'ROW (named)';
        }

        return 'UNKNOWN';
    }
}
